<!--
Copyright 2024 Matthias Müller - Ten Minute Physics, 
www.youtube.com/c/TenMinutePhysics
www.matthiasMueller.info/tenMinutePhysics

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->

<!--
To run:
start a server: python -m http.server 8000
install Install "Live Server" extension in VSCode
Right-click your HTML file → "Open with Live Server"
-->

<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<html lang="en">
	<head>
		<title>Joint Simulation</title>
		<style>
			body {
				font-family: verdana; 
				font-size: 15px;
			}			
			.button {
                background-color: #606060;
                border: none;
                color: white;
                padding: 15px 32px;
                font-size: 16px;
                margin: 4px 2px;
                cursor: pointer;
		    }
            .styled-select {
                appearance: none;
                background-color: #606060;
                border: none;
                color: white;
                padding: 15px 32px;
                font-size: 16px;
                margin: 4px 2px;
                cursor: pointer;
            }
            /* Custom checkbox styling */
            .visual-toggle {
                display: none;
            }
            .visual-toggle-label {
                background-color: #606060;
                color: white;
                padding: 15px 32px;
                font-size: 16px;
                margin: 4px 2px;
                cursor: pointer;
                display: inline-block;
                user-select: none;
                transition: background-color 0.3s;
            }
            .visual-toggle-label:hover {
                background-color: #707070;
            }
            .visual-toggle:checked + .visual-toggle-label {
                background-color: #606060;
            }
            /* Touch control styling */
            #touchControl {
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 150px;
                height: 150px;
                pointer-events: none;
            }
            #outerCircle {
                position: absolute;
                width: 100%;
                height: 100%;
                border-radius: 0%;
                background-color: rgba(96, 96, 96, 0.5);
                pointer-events: auto;
            }
            #innerCircle {
                position: absolute;
                width: 40%;
                height: 40%;
                border-radius: 50%;
                background-color: rgba(255, 255, 255, 0.8);
                pointer-events: none;
                transform: translate(-50%, -50%);
            }
		</style>	
	</head>
	
	<body>

        <h1>Joint Simulation</h1> 
		<button id = "startButton" onclick="onStart()" class="button">Start</button>
		<button id = "startRestart" onclick="onRestart()" class="button">Restart</button>
		<button id = "toggleView" onclick="onToggleView()" class="button">Toggle View</button>
		<select id="sceneSelect" class="styled-select" onchange="onSceneChange()">
			<option value="0">Basic Joints</option>
			<option value="1">Steering</option>
			<option value="2">Pendulums</option>
		</select>

		<br><br>		
        <div id="container"></div>
        <div id="touchControl">
            <div id="outerCircle"></div>
            <div id="innerCircle"></div>
        </div>
        
        <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
        
        <script>

			// ------------------------------------------------------------------

			class RigidBody 
            {
                constructor(scene, type, size, density, pos, angles, fontSize = 0.0) 
                {
                    this.type = type;
                    this.size = new THREE.Vector3(size.x, size.y, size.z);
                    this.dt = 0.0;

                    this.pos = new THREE.Vector3(pos.x, pos.y, pos.z);
                    this.rot = new THREE.Quaternion();
                    this.rot.setFromEuler(new THREE.Euler(angles.x, angles.y, angles.z));
                    this.vel = new THREE.Vector3(0.0, 0.0, 0.0);
                    this.omega = new THREE.Vector3(0.0, 0.0, 0.0);

                    this.prevPos = this.pos.clone();
                    this.prevRot = this.rot.clone();
                    this.invRot = this.rot.clone();
                    this.invRot.invert();

                    this.invMass = 0.0;
                    this.invInertia = new THREE.Vector3();

                    this.meshes = [];
                    this.vertices = null;
                    this.triIds = null;
                    let mass = 0.0;

                    if (type == "box") 
                    {
                        let mesh = new THREE.Mesh(
                            new THREE.BoxBufferGeometry(size.x, size.y, size.z),
                            new THREE.MeshPhongMaterial({ color: 0xffffff })
                        );
                        this.meshes.push(mesh);
                        if (density > 0.0)
                        {
                            mass = density * size.x * size.y * size.z;
                            this.invMass = 1.0 / mass;
                            let Ix = 1.0 / 12.0 * mass * (size.y * size.y + size.z * size.z);
                            let Iy = 1.0 / 12.0 * mass * (size.x * size.x + size.z * size.z);
                            let Iz = 1.0 / 12.0 * mass * (size.x * size.x + size.y * size.y);
                            this.invInertia.set(1.0 / Ix, 1.0 / Iy, 1.0 / Iz);
                        }
                        let ex = 0.5 * size.x;
                        let ey = 0.5 * size.y;
                        let ez = 0.5 * size.z;

                        this.vertices = new Float32Array([
                            -ex, -ey, -ez,
                            ex, -ey, -ez,
                            ex, ey, -ez,
                            -ex, ey, -ez,
                            -ex, -ey, ez,
                            ex, -ey, ez,
                            ex, ey, ez,
                            -ex, ey, ez
                        ]);
                    }
                    else if (type == "sphere") 
                    {
                        let hemiSphere0 = new THREE.Mesh(
                            new THREE.SphereBufferGeometry(size.x, 32, 32, 0.0, Math.PI),
                            new THREE.MeshPhongMaterial({ color: 0xffffff })
                        );
                        let hemiSphere1 = new THREE.Mesh(
                            new THREE.SphereBufferGeometry(size.x, 32, 32, Math.PI, Math.PI),
                            new THREE.MeshPhongMaterial({ color: 0xff0000 })
                        );
                        this.meshes.push(hemiSphere0);
                        this.meshes.push(hemiSphere1);
                        if (density > 0.0)
                        {
                            mass = 4.0 / 3.0 * Math.PI * size.x * size.x * size.x * density;
                            this.invMass = 1.0 / mass;
                            let I = 2.0 / 5.0 * mass * size.x * size.x;
                            this.invInertia.set(1.0 / I, 1.0 / I, 1.0 / I);
                        }
                    }

                    for (let i = 0; i < this.meshes.length; i++) {
                        let mesh = this.meshes[i];
                        mesh.body = this;		// for raycasting
                        mesh.layers.enable(1);
                        mesh.castShadow = true;
				        mesh.receiveShadow = true;
                        scene.add(mesh);
                    }

                    this.firstVisualMesh = this.meshes.length;
                    this.showVisuals = true;
                    
                    this.updateMeshes();
                }

                updateMeshes()
                {
                    for (let i = 0; i < this.meshes.length; i++)
                    {
                        this.meshes[i].position.copy(this.pos);
                        this.meshes[i].quaternion.copy(this.rot);
    					this.meshes[i].geometry.computeBoundingSphere();
                        this.meshes[i].visible = (i < this.firstVisualMesh) !== this.showVisuals;
                    }
                }
                
                showSimulationView(show)
                {
                    this.showVisuals = show;
                    this.updateMeshes();
                }

                // begin simulation functions

                getVelocityAt(pos)
                {
                    let vel = new THREE.Vector3(0.0, 0.0, 0.0);
                    if (this.invMass > 0.0)
                    {
                        vel.subVectors(pos, this.pos);
                        vel.cross(this.omega);
                        vel.multiplyScalar(-1.0);
                        vel.add(this.vel);
                    }
                    return vel;
                }

                localToWorld(localPos, worldPos)
                {
                    worldPos.copy(localPos);
                    worldPos.applyQuaternion(this.rot);
                    worldPos.add(this.pos);
                }

                worldToLocal(worldPos, localPos)
                {
                    localPos.copy(worldPos);
                    localPos.sub(this.pos);
                    localPos.applyQuaternion(this.invRot);
                }

                integrate(dt, gravity)
                {
                    this.dt = dt;

                    if (this.invMass == 0.0)
                        return;

                    // linear motion
                    this.prevPos.copy(this.pos);
                    this.vel.addScaledVector(gravity, dt);
                    this.pos.addScaledVector(this.vel, dt);

                    // angular motion
                    this.prevRot.copy(this.rot);
                    let dRot = new THREE.Quaternion(
                        this.omega.x,
                        this.omega.y,
                        this.omega.z,
                        0.0
                    );
                    dRot.multiply(this.rot);
                    this.rot.x += 0.5 * dt * dRot.x;
                    this.rot.y += 0.5 * dt * dRot.y;
                    this.rot.z += 0.5 * dt * dRot.z;
                    this.rot.w += 0.5 * dt * dRot.w;
                    this.rot.normalize();
                    this.invRot.copy(this.rot);
                    this.invRot.invert();
                }

                updateVelocities()
                {   
                    if (this.invMass == 0.0)
                        return;

                    // linear motion
                    this.vel.subVectors(this.pos, this.prevPos);
                    this.vel.multiplyScalar(1.0 / this.dt);

                    // angular motion
                    this.prevRot.invert();
                    let dRot = new THREE.Quaternion();
                    dRot.multiplyQuaternions(this.rot, this.prevRot);
                    this.omega.set(
                        dRot.x * 2.0 / this.dt,
                        dRot.y * 2.0 / this.dt,
                        dRot.z * 2.0 / this.dt
                    );
                    if (dRot.w < 0.0)
                        this.omega.negate();
                }

                getInverseMass(normal, pos)
                {
                    if (this.invMass == 0.0)
                        return 0.0;

                    let rn = normal.clone();

                    if (pos)  
                    {
                        rn.subVectors(pos, this.pos);
                        rn.cross(normal);
                        rn.applyQuaternion(this.invRot);
                    }
                    else           
                    {
                        rn.applyQuaternion(this.invRot);
                    }

                    let w = 
                        rn.x * rn.x * this.invInertia.x + 
                        rn.y * rn.y * this.invInertia.y + 
                        rn.z * rn.z * this.invInertia.z;

                    if (pos)
                        w += this.invMass;
                 
                    return w;
                }

                _applyCorrection(corr, pos, velocityLevel)
                {
                    if (this.invMass == 0.0)
                        return;

                    // linear correction

                    if (pos) 
                    {
                        if (velocityLevel)
                            this.vel.addScaledVector(corr, this.invMass);
                        else
                            this.pos.addScaledVector(corr, this.invMass);
                    }

                    // angular correction

                    let dOmega = corr.clone();

                    if (pos)
                    {
                        dOmega.subVectors(pos, this.pos);
                        dOmega.cross(corr);
                    }
                    
                    dOmega.applyQuaternion(this.invRot);
                    dOmega.multiply(this.invInertia);
                    dOmega.applyQuaternion(this.rot);

                    if (velocityLevel)
                    {
                        this.omega.add(dOmega);
                    }
                    else
                    {
                        // stabilize rotation
                        dOmega.multiplyScalar(0.5);
                        

                        let dRot = new THREE.Quaternion(
                            dOmega.x,
                            dOmega.y,
                            dOmega.z,
                            0.0
                        );

                        dRot.multiply(this.rot);
                        this.rot.x += 0.5 * dRot.x;
                        this.rot.y += 0.5 * dRot.y;
                        this.rot.z += 0.5 * dRot.z;
                        this.rot.w += 0.5 * dRot.w;
                        this.rot.normalize();
                        this.invRot.copy(this.rot);
                        this.invRot.invert();
                    }
                }

                applyCorrection(compliance, corr, pos, otherBody, otherPos, velocityLevel = false)
                {
                    if (corr.lengthSq() == 0.0)
                        return;

                    let C = corr.length();
                    let normal = corr.clone();
                    normal.normalize();

                    let w = this.getInverseMass(normal, pos);
                    if (otherBody)
                        w += otherBody.getInverseMass(normal, otherPos);

                    if (w == 0.0)
                        return;

                    let lambda = -C / w;

                    if (!velocityLevel)
                    {
                        // XPBD
                        let alpha = compliance / this.dt / this.dt;
                        lambda = -C / (w + alpha);
                    }
                    normal.multiplyScalar(-lambda);

                    this._applyCorrection(normal, pos, velocityLevel);
                    if (otherBody) {
                        normal.multiplyScalar(-1.0);
                        otherBody._applyCorrection(normal, otherPos, velocityLevel);
                    }
                    return lambda / this.dt / this.dt;
                }
              
                // end simulation functions
            }

            class VisualDistance {
                constructor(scene, width = 0.01, color = 0xff0000) {
                    this.scene = scene;
                    
                    // Create a cylinder for visualization
                    const geometry = new THREE.CylinderGeometry(width, width, 1, 32);
                    const material = new THREE.MeshBasicMaterial({ color: color });
                    this.cylinder = new THREE.Mesh(geometry, material);
                    this.cylinder.castShadow = true;
                    this.cylinder.receiveShadow = true;
                    scene.add(this.cylinder);
                }
                
                updateMesh(startPos, endPos) {
                    // Calculate the center point
                    const center = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
                    
                    // Calculate the direction vector
                    const direction = new THREE.Vector3().subVectors(endPos, startPos);
                    const length = direction.length();
                    
                    // Create a rotation quaternion
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), direction.normalize());
                    
                    // Update cylinder's transformation
                    this.cylinder.position.copy(center);
                    this.cylinder.setRotationFromQuaternion(quaternion);
                    this.cylinder.scale.set(1, length, 1);
                    
                    return length;
                }

                setVisible(visible) {
                    this.cylinder.visible = visible;
                }
            }

            class VisualFrame {
                constructor(scene, width, size = 0.1) {
                    // Create axis line objects
                    this.axes = {
                        x: this.createAxis(width, size, 0xff0000), // Red for X-axis
                        y: this.createAxis(width, size, 0x00ff00), // Green for Y-axis
                        z: this.createAxis(width, size, 0x0000ff)  // Blue for Z-axis
                    };
                    
                    // Add axes to scene
                    scene.add(this.axes.x);
                    scene.add(this.axes.y);
                    scene.add(this.axes.z);
                }
                
                createAxis(width, size, color) {
                    // Create a line representing an axis
                    const material = new THREE.MeshBasicMaterial({ color });
                    const geometry = new THREE.CylinderGeometry(width, width, size, 8);
                    
                    // Position the cylinder so it starts at the origin and extends in positive direction
                    geometry.translate(0, size/2, 0);
                    
                    const line = new THREE.Mesh(geometry, material);
                    return line;
                }
                
                updateMesh(pos, rot) {
                    // Extract basis vectors from quaternion
                    const xAxis = new THREE.Vector3(1, 0, 0).applyQuaternion(rot);
                    const yAxis = new THREE.Vector3(0, 1, 0).applyQuaternion(rot);
                    const zAxis = new THREE.Vector3(0, 0, 1).applyQuaternion(rot);
                    
                    // Update X axis (red)
                    this.axes.x.position.copy(pos);
                    this.axes.x.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0), 
                        xAxis.clone().normalize()
                    );
                    
                    // Update Y axis (green)
                    this.axes.y.position.copy(pos);
                    this.axes.y.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0), 
                        yAxis.clone().normalize()
                    );
                    
                    // Update Z axis (blue)
                    this.axes.z.position.copy(pos);
                    this.axes.z.quaternion.setFromUnitVectors(
                        new THREE.Vector3(0, 1, 0), 
                        zAxis.clone().normalize()
                    );
                }
                setVisible(visible) {
                    this.axes.x.visible = visible;
                    this.axes.y.visible = visible;
                    this.axes.z.visible = visible;
                }
            }


            class Joint {
                static TYPES = {
                    NONE: 'none',
                    DISTANCE: 'distance',
                    HINGE: 'hinge',
                    SERVO: 'servo',
                    MOTOR: 'motor',
                    BALL: 'ball',
                    PRISMATIC: 'prismatic',
                    CYLINDER: 'cylinder',
                    FIXED: 'fixed',
                };
                constructor(body0, body1, globalFramePos, globalFrameRot = null)
                {
                    this.type = Joint.TYPES.NONE;
                    this.body0 = body0;
                    this.body1 = body1;
                    this.diabled = false;

                    if (!globalFrameRot) {
                        globalFrameRot = new THREE.Quaternion(0.0, 0.0, 0.0, 1.0);
                    }

                    // distance

                    this.hasTargetDistance = false;
                    this.targetDistance = 0.0;
                    this.distanceCompliance = 0.0;
                    this.distanceMin = -Number.MAX_VALUE;
                    this.distanceMax = Number.MAX_VALUE;
                    this.linearDampingCoeff = 0.0;

                    // orientation

                    this.swingMin = -Number.MAX_VALUE;
                    this.swingMax = Number.MAX_VALUE;
                    this.twistMin = -Number.MAX_VALUE;
                    this.twistMax = Number.MAX_VALUE;
                    this.targetAngle = 0.0;
                    this.hasTargetAngle = false;
                    this.targetAngleCompliance = 0.0;
                    this.angularDampingCoeff = 0.0;

                    // motor
                    this.velocity = 0.0;

                    this.globalPos0 = globalFramePos.clone();
                    this.globalRot0 = globalFrameRot.clone();
                    this.globalPos1 = globalFramePos.clone();
                    this.globalRot1 = globalFrameRot.clone();

                    this.localPos0 = globalFramePos.clone();
                    this.localRot0 = globalFrameRot.clone();
                    this.localPos1 = globalFramePos.clone();
                    this.localRot1 = globalFrameRot.clone();

                    this.setFrames(globalFramePos, globalFrameRot);

                    this.visFrame0 = null;
                    this.visFrame1 = null;
                    this.visDistance = null;
                }

                setFrames(globalFramePos, globalFrameRot = null)
                {
                    if (!globalFrameRot) {
                        globalFrameRot = new THREE.Quaternion(0.0, 0.0, 0.0, 1.0);
                    }
                    
                    if (this.body0) {
                        // Store the local position relative to body0
                        this.localPos0.subVectors(globalFramePos, this.body0.pos);
                        this.localPos0.applyQuaternion(this.body0.invRot);
                        
                        // Store the local rotation relative to body0
                        this.localRot0.copy(globalFrameRot);
                        // Factor out the body's rotation
                        if (globalFrameRot) {
                            this.localRot0.premultiply(this.body0.invRot);
                        }
                    } else {
                        this.localPos0.copy(globalFramePos);
                        this.localRot0.copy(globalFrameRot);
                    }
                    
                    if (this.body1) {
                        // Store the local position relative to body1
                        this.localPos1.subVectors(globalFramePos, this.body1.pos);
                        this.localPos1.applyQuaternion(this.body1.invRot);
                        
                        // Store the local rotation relative to body1
                        this.localRot1.copy(globalFrameRot);
                        // Factor out the body's rotation
                        if (globalFrameRot) {
                            this.localRot1.premultiply(this.body1.invRot);
                        }
                    } else {
                        this.localPos1.copy(globalFramePos);
                        this.localRot1.copy(globalFrameRot);
                    }
                }

                setVisible(visible)
                {
                    if (this.visFrame0 != null)
                        this.visFrame0.setVisible(visible);
                    if (this.visFrame1 != null)
                        this.visFrame1.setVisible(visible);
                    if (this.visDistance != null)
                        this.visDistance.setVisible(visible);
                }

                setDisabled(disabled)
                {
                    this.disabled = disabled;
                    this.setVisible(!disabled);
                }

                initHingeJoint(swingMin, swingMax, hasTargetAngle, targetAngle, compliance, damping)
                {
                    this.type = Joint.TYPES.HINGE;
                    this.hasTargetDistance = true;
                    this.targetDistance = 0.0;
                    this.swingMin = swingMin;
                    this.swingMax = swingMax;
                    this.hasTargetAngle = hasTargetAngle;
                    this.targetAngle = targetAngle;
                    this.targetAngleCompliance = compliance;
                    this.angularDampingCoeff = damping;
                }

                initServo(swingMin, swingMax)
                {
                    this.type = Joint.TYPES.SERVO;
                    this.hasTargetDistance = true;
                    this.targetDistance = 0.0;
                    this.swingMin = swingMin;
                    this.swingMax = swingMax;
                    this.hasTargetAngle = true;
                    this.targetAngle = 0.0;
                    this.targetAngleCompliance = 0.0;
                }     
                initMotor(velocity)
                {
                    this.type = Joint.TYPES.MOTOR;
                    this.hasTargetDistance = true;
                    this.targetDistance = 0.0;
                    this.velocity = velocity;
                    this.hasTargetAngle = true;
                    this.targetAngle = 0.0;
                    this.targetAngleCompliance = 0.0
                }  
                initBallJoint(swingMax, twistMin, twistMax, damping)
                {
                    this.type = Joint.TYPES.BALL;
                    this.hasTargetDistance = true;
                    this.targetDistance = 0.0;
                    this.swingMin = 0.0;
                    this.swingMax = swingMax;
                    this.twistMin = twistMin;
                    this.twistMax = twistMax;
                    this.angularDampingCoeff = damping;
                }

                initPrismaticJoint(distanceMin, distanceMax, twistMin, twistMax, hasTarget, targetDistance, targetCompliance, damping)
                {
                    this.type = Joint.TYPES.PRISMATIC;
                    this.distanceMin = distanceMin;
                    this.distanceMax = distanceMax;
                    this.swingMin = 0.0;
                    this.swingMax = 0.0;
                    this.twistMin = twistMin;
                    this.twistMax = twistMax;
                    this.hasTargetDistance = hasTarget;
                    this.targetDistance = targetDistance;
                    this.distanceCompliance = targetCompliance;
                    this.linearDampingCoeff = damping;
                }
                
                initCylinderJoint(distanceMin, distanceMax, twistMin, twistMax, hasTargetDistance, restDistance, compliance, damping)
                {
                    this.type = Joint.TYPES.CYLINDER;
                    this.distaceMin = distanceMin;
                    this.distanceMax = distanceMax;
                    this.swingMin = 0.0;
                    this.swingMax = 0.0;
                    this.twistMin = twistMin;
                    this.twistMax = twistMax;
                    this.hasTargetDistance = true;
                    this.distanceCompliance = 0.0;
                }

                initDistanceJoint(restDistance, compliance, damping)
                {
                    this.type = Joint.TYPES.DISTANCE;
                    this.hasTargetDistance = true;
                    this.targetDistance = restDistance;
                    this.distanceCompliance = compliance;
                    this.linearDampingCoeff = damping;
                }

                applyTorque(dt, torque)
                {
                    updateGlobalFrames();

                    // assumng x-axis is the hinge axis

                    let corr = new THREE.Vector3(1.0, 0.0, 0.0);
                    corr.applyQuaternion(this.globalRot0);
                    corr.multiplyScalar(torque* dt);

                    this.body0.applyCorrection(0.0, corr, null, this.body1, null, true);
                }

                solvePosition(dt) 
                {
                    let hardCompliance = 0.0;

                    if (this.disabled || this.type == Joint.TYPES.NONE)
                        return;

                    let corr = new THREE.Vector3();

                    // align
                    
                    // if (this.type == Joint.TYPES.PRISMATIC || this.type == Joint.TYPES.CYLINDER)
                    // {   
                    //     this.targetDistance = Math.max(this.distanceMin, Math.min(this.targetDistance, this.distanceMax));
                    //     let hardCompliance = 0.0;
                    //     this.updateGlobalFrames();
                    //     corr.subVectors(this.globalPos1, this.globalPos0);

                    //     corr.applyQuaternion(this.globalRot0.clone().conjugate());
                    //     if (this.type == Joint.TYPES.CYLINDER)
                    //         corr.x -= this.targetDistance;
                    //     else if (corr.x > this.distanceMax)
                    //         corr.x -= this.distanceMax;
                    //     else if (corr.x < this.distanceMin)
                    //         corr.x -= this.distanceMin;
                    //     else
                    //         corr.x = 0.0; 

                    //     corr.applyQuaternion(this.globalRot0);
                    //     this.body0.applyCorrection(hardCompliance, corr, this.globalPos0, this.body1, this.globalPos1);                    
                    // }

                    // solve distance

                    if (this.type != Joint.TYPES.CYLINDER && this.hasTargetDistance)
                    {
                        this.updateGlobalFrames();
                        corr.subVectors(this.globalPos1, this.globalPos0);
                        let distance = corr.length();
                        if (distance == 0.0)
                        {
                            corr.set(0.0, 0.0, 1.0);
                            corr.applyQuaternion(this.globalRot0);
                        }
                        else
                            corr.normalize();

                        corr.multiplyScalar(this.targetDistance - distance);
                        corr.multiplyScalar(-1.0);
                        this.body0.applyCorrection(this.distanceCompliance, corr, this.globalPos0, this.body1, this.globalPos1);
                    }
                }    

                updateGlobalFrames() 
                {
                    if (this.body0) {
                        this.globalPos0.copy(this.localPos0);
                        this.globalPos0.applyQuaternion(this.body0.rot);
                        this.globalPos0.add(this.body0.pos);
                        this.globalRot0.multiplyQuaternions(this.body0.rot, this.localRot0);
                    }
                    
                    if (this.body1) {
                        this.globalPos1.copy(this.localPos1);
                        this.globalPos1.applyQuaternion(this.body1.rot);
                        this.globalPos1.add(this.body1.pos);
                        this.globalRot1.multiplyQuaternions(this.body1.rot, this.localRot1);
                    }
                    else {
                        this.globalPos1.copy(this.localPos1);
                        this.globalRot1.copy(this.localRot1);
                    }
                }

                getAngle(n, a, b) 
                {
                    const c = new THREE.Vector3().crossVectors(a, b);
                    let phi = Math.asin(c.dot(n));
                    if (a.dot(b) < 0.0) 
                        phi = Math.PI - phi;
                    if (phi > Math.PI) 
                        phi -= 2.0 * Math.PI;
                    if (phi < -Math.PI) 
                        phi += 2.0 * Math.PI;
                    return phi;
                }

                limitAngle(n, a, b, minAngle, maxAngle, compliance)
                {
                    let phi = this.getAngle(n, a, b);

                    if (minAngle <= phi && phi <= maxAngle)
                        return;
                    phi = Math.max(minAngle, Math.min(phi, maxAngle));

                    let ra = a.clone();
                    ra.applyAxisAngle(n, phi);

                    let corr = new THREE.Vector3().crossVectors(ra, b);
                    this.body0.applyCorrection(compliance, corr, null, this.body1, null);
                }
            
                solveOrientation(dt)
                {
                    if (this.disabled || this.type == Joint.TYPES.NONE || this.type == Joint.TYPES.DISTANCE)
                    {
                        return;
                    }    

                    if (this.type == Joint.TYPES.MOTOR)
                    {
                        let aAngle = Math.min(Math.max(this.velocity * dt, -1.0), 1.0);
                        this.targetAngle += aAngle;
                    }
                    
                    let hardCompliance = 0.0;
                    let axis0 = new THREE.Vector3(1.0, 0.0, 0.0);
                    let axis1 = new THREE.Vector3(0.0, 1.0, 0.0);
                    let a0 = new THREE.Vector3();
                    let a1 = new THREE.Vector3();
                    let n = new THREE.Vector3();
                    let corr = new THREE.Vector3();

                    if (this.type == Joint.TYPES.HINGE || this.type == Joint.TYPES.SERVO || this.type == Joint.TYPES.MOTOR)
                    {
                        // align axes

                        this.updateGlobalFrames();

                        a0.copy(axis0);
                        a0.applyQuaternion(this.globalRot0);
                        a1.copy(axis0);
                        a1.applyQuaternion(this.globalRot1);
                        corr.crossVectors(a0, a1);
                        this.body0.applyCorrection(hardCompliance, corr, null, this.body1, null);

                        if (this.hasTargetAngle)
                        {
                            this.updateGlobalFrames();
                            n.copy(axis0);
                            n.applyQuaternion(this.globalRot0);
                            a0.copy(axis1);
                            a0.applyQuaternion(this.globalRot0);
                            a1.copy(axis1);
                            a1.applyQuaternion(this.globalRot1);
                            this.limitAngle(n, a0, a1, this.targetAngle, this.targetAngle, this.targetAngleCompliance);
                        }

                        // joint limits

                        if (this.swingMin > -Number.MAX_VALUE || this.swingMax < Number.MAX_VALUE)
                        {
                            this.updateGlobalFrames();
                            
                            n.copy(axis0);
                            n.applyQuaternion(this.globalRot0);
                            a0.copy(axis1);
                            a0.applyQuaternion(this.globalRot0);
                            a1.copy(axis1);
                            a1.applyQuaternion(this.globalRot1);
                            this.limitAngle(n, a0, a1, this.swingMin, this.swingMax, hardCompliance);
                        }
                    }
                    else if (this.type == Joint.TYPES.BALL || this.type == Joint.TYPES.PRISMATIC || this.type == Joint.TYPES.CYLINDER)
                    {
                        // swing limit

                        this.updateGlobalFrames();

                        a0.copy(axis0);
                        a0.applyQuaternion(this.globalRot0);
                        a1.copy(axis0);
                        a1.applyQuaternion(this.globalRot1);   
                        n.crossVectors(a0, a1);
                        n.normalize();
                        // this.limitAngle(n, a0, a1, this.swingMin, this.swingMax, hardCompliance);

                        // twist limit

                        this.updateGlobalFrames();

                        a0.copy(axis0);
                        a0.applyQuaternion(this.globalRot0);
                        a1.copy(axis0);
                        a1.applyQuaternion(this.globalRot1);   
                        n.addVectors(a0, a1);
                        n.normalize();

                        a0.copy(axis1);
                        a0.applyQuaternion(this.globalRot0);
                        a1.copy(axis1);
                        a1.applyQuaternion(this.globalRot1);

                        a0.addScaledVector(n, -n.dot(a0));
                        a0.normalize();
                        a1.addScaledVector(n, -n.dot(a1));
                        a1.normalize();
                        this.limitAngle(n, a0, a1, this.twistMin, this.twistMax, hardCompliance);
                    }
                    else if (this.type == Joint.TYPES.FIXED)
                    {
                        // align orientations

                        this.updateGlobalFrames();

                        let dq = new THREE.Quaternion();
                        dq.multiplyQuaternions(this.globalRot0, this.globalRot1.conjugate());
                        corr.set(2.0 * dq.x, 2.0 * dq.y, 2.0 * dq.z);
                        if (dq.w > 0.0)
                            corr.multiplyScalar(-1.0);

                        this.body0.applyCorrection(hardCompliance, corr, null, this.body1, null);
                    }
                }

                solve(dt)
                {
                    this.solvePosition(dt);
                    this.solveOrientation(dt);
                }

                applyLinearDamping(dt)
                {
                    this.updateGlobalFrames();

                    let dVel = this.body0.getVelocityAt(this.globalPos0);
                    if (this.body1 != null)
                        dVel.sub(this.body1.getVelocityAt(this.globalPos1));

                    // only damp along the distance vector

                    let n = new THREE.Vector3();
                    n.subVectors(this.globalPos1, this.globalPos0);
                    n.normalize();
                    n.multiplyScalar(-dVel.dot(n));
                    n.multiplyScalar(Math.min(this.linearDampingCoeff * dt, 1.0));                    
                    this.body0.applyCorrection(0.0, n, this.globalPos0, this.body1, this.globalPos1, true);
                }
       
                applyAngularDamping(dt, coeff = this.angularDampingCoeff)
                {
                    this.updateGlobalFrames();

                    let dOmega = this.body0.omega.clone();
                    if (this.body1 != null)
                        dOmega.sub(this.body1.omega);

                    if (this.type == Joint.TYPES.HINGE)
                    {
                        // damp along the hinge axis
                        let n = new THREE.Vector3(1.0, 0.0, 0.0);
                        n.applyQuaternion(this.globalRot0);
                        n.multiplyScalar(dOmega.dot(n));
                        dOmega.copy(n);
                    }
                    if (this.type == Joint.TYPES.CYLINDER || this.type == Joint.TYPES.PRISMATIC || this.type == Joint.TYPES.FIXED)
                        dOmega.multiplyScalar(-1.0); // maximum damping
                    else
                        dOmega.multiplyScalar(-Math.min(this.angularDampingCoeff * dt, 1.0));
                    this.body0.applyCorrection(0.0, dOmega, null, this.body1, null, true);
                }

                addVisuals(scene, width = 0.004, size = 0.08)
                {
                    if (this.visFrame0 == null)
                    {
                        this.visFrame0 = new VisualFrame(scene, width, size);
                        this.visFrame1 = new VisualFrame(scene, width, size);
                    }

                    if (this.visDistance == null) {
                        this.visDistance = new VisualDistance(scene, width);
                    }
                    this.updateVisuals();
                }

                updateVisuals() 
                {
                    if (this.disabled)
                        return;

                    this.updateGlobalFrames();                    // Calculate the actual world positions for joint attachment points
                    
                    if (this.visFrame0)
                        this.visFrame0.updateMesh(this.globalPos0, this.globalRot0);
                    if (this.visFrame1)
                        this.visFrame1.updateMesh(this.globalPos1, this.globalRot1);
                    if (this.visDistance != null) 
                        this.visDistance.updateMesh(this.globalPos0, this.globalPos1);
                } 
            }            
			
			// ------------------------------------------------------------------

            class RigidBodySimulator 
            {
				constructor(scene, gravity)
				{
                    this.scene = scene;
                    this.gravity = gravity.clone();
                    this.dt = 0.03333; // 30 FPS
                    this.numSubSteps = 20;
                    this.numIterations = 1;
                    this.rigidBodies = [];
                    this.joints = [];

                    this.addDragJoint(scene);
                    this.simulationView = true;

                    // Touch control state
                    this.controlVector = new THREE.Vector2(0, 0);
                    this.controlVelocity = new THREE.Vector2(0, 0);
                    this.isDragging = false;
                    this.setupTouchControl();
                }

                setupTouchControl() {
                    const outerCircle = document.getElementById('outerCircle');
                    const innerCircle = document.getElementById('innerCircle');
                    const touchControl = document.getElementById('touchControl');

                    // Initialize inner circle to center
                    innerCircle.style.left = '50%';
                    innerCircle.style.top = '50%';

                    const updateControl = (clientX, clientY) => {
                        const rect = touchControl.getBoundingClientRect();
                        const centerX = rect.left + rect.width / 2;
                        const centerY = rect.top + rect.height / 2;
                        
                        // Calculate vector from center to touch point
                        let dx = clientX - centerX;
                        let dy = clientY - centerY;
                        
                        // Normalize and clamp to square
                        const maxRadius = rect.width / 2;
                        if (Math.abs(dx) > maxRadius) {
                            dx = Math.sign(dx) * maxRadius;
                        }
                        if (Math.abs(dy) > maxRadius) {
                            dy = Math.sign(dy) * maxRadius;
                        }
                        
                        // Update inner circle position
                        innerCircle.style.left = (rect.width / 2 + dx) + 'px';
                        innerCircle.style.top = (rect.height / 2 + dy) + 'px';
                        
                        // Store normalized control vector (-1 to 1)
                        this.controlVector.set(dx / maxRadius, -dy / maxRadius);
                        this.controlVelocity.set(0, 0); // Reset velocity when actively controlling
                    };

                    const onPointerDown = (e) => {
                        this.isDragging = true;
                        updateControl(e.clientX, e.clientY);
                        if (gPaused)
                            onStart();
                    };

                    const onPointerMove = (e) => {
                        if (this.isDragging) {
                            updateControl(e.clientX, e.clientY);
                        }
                    };

                    const onPointerUp = () => {
                        this.isDragging = false;
                    };

                    outerCircle.addEventListener('pointerdown', onPointerDown);
                    document.addEventListener('pointermove', onPointerMove);
                    document.addEventListener('pointerup', onPointerUp);
                }

                addDragJoint() 
                {
                    let dragCompliance = 0.01;
                    let dragDamping = 0.1;
                    this.dragJoint = new Joint(null, null, new THREE.Vector3(0.0, 0.0, 0.0));
                    this.dragJoint.initDistanceJoint(0.0, dragCompliance, dragDamping);                    
                    this.dragJoint.addVisuals(this.scene);
                    this.dragJoint.setDisabled(true);
                }

                clear()
                {
                    this.rigidBodies = [];
                    this.joints = [];
                    this.addDragJoint();
                }

                toggleView()
                {
                    this.simulationView = !this.simulationView;
                    for (let i = 0; i < this.rigidBodies.length; i++)
                        this.rigidBodies[i].showSimulationView(this.simulationView);
                    for (let i = 0; i < this.joints.length; i++)
                        this.joints[i].setVisible(!this.simulationView);
                }

                addRigidBody(rigidBody)
                {
                    this.rigidBodies.push(rigidBody);
                }

                addJoint(joint)
                {
                    this.joints.push(joint);
                }

                updateControl() {
                    // Update control vector with velocity
                    if (!this.isDragging) {
                        const returnSpeed = 5.0; // Adjust this value to control return speed
                        this.controlVelocity.x = -this.controlVector.x * returnSpeed;
                        this.controlVelocity.y = -this.controlVector.y * returnSpeed;
                        this.controlVector.add(this.controlVelocity.multiplyScalar(this.dt));
                        
                        // Update inner circle position
                        const innerCircle = document.getElementById('innerCircle');
                        const touchControl = document.getElementById('touchControl');
                        const rect = touchControl.getBoundingClientRect();
                        const maxRadius = rect.width / 2;
                        innerCircle.style.left = (rect.width / 2 + this.controlVector.x * maxRadius) + 'px';
                        innerCircle.style.top = (rect.height / 2 - this.controlVector.y * maxRadius) + 'px';
                    }

                    // Apply control to motors and servos
                    for (let i = 0; i < this.joints.length; i++) {
                        const joint = this.joints[i];
                        if (joint.type === Joint.TYPES.MOTOR) {
                            joint.velocity = this.controlVector.y * 5.0; // Scale factor for motor speed
                        }
                        else if (joint.type === Joint.TYPES.SERVO) {
                            joint.targetAngle = this.controlVector.x * Math.PI / 4; // Scale factor for steering angle
                        }
                        else if (joint.type === Joint.TYPES.CYLINDER) {
                            joint.targetDistance = -this.controlVector.y * 0.1; // Scale factor for offset
                        }
                    }
                }

                simulate()
				{
                    this.updateControl();

                    let sdt = this.dt / this.numSubSteps;

                    for (let subStep = 0; subStep < this.numSubSteps; subStep++)
                    {
                        for (let i = 0; i < this.rigidBodies.length; i++)
                            this.rigidBodies[i].integrate(sdt, this.gravity);

                        for (let i = 0; i < this.joints.length; i++)
                            this.joints[i].solve(sdt);

                        if (this.dragJoint)
                            this.dragJoint.solve(sdt);

                        for (let i = 0; i < this.rigidBodies.length; i++)
                        {
                            this.rigidBodies[i].updateVelocities(sdt);
                        }

                        for (let i = 0; i < this.joints.length; i++)
                        {
                            this.joints[i].applyLinearDamping(sdt);
                            this.joints[i].applyAngularDamping(sdt);
                        }
                    }

                    for (let i = 0; i < this.rigidBodies.length; i++)
                        this.rigidBodies[i].updateMeshes();

                    for (let i = 0; i < this.joints.length; i++)
                        this.joints[i].updateVisuals();

                    if (this.dragJoint)
                        this.dragJoint.updateVisuals();
				}

                startDrag(body, pos)
                {
                    this.dragJoint.body0 = body;
                    this.dragJoint.setFrames(pos);
                    this.dragJoint.setDisabled(false);
                }

                drag(pos)
                {
                    this.dragJoint.localPos1.copy(pos);
                }

                endDrag(pos)
                {
                    this.dragJoint.setDisabled(true);
                }
            }

   			// ------------------------------------------------------------------

            class SceneImporter {
                constructor(simulator, scene) {
                    this.simulator = simulator;
                    this.scene = scene;
                    this.rigidBodies = new Map(); // name -> RigidBody lookup
                }

                loadScene(jsonData) {
                    // Parse JSON if it's a string
                    const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    
                    // Check if scene data is empty
                    if (!data || Object.keys(data).length === 0 || !data.meshes || data.meshes.length === 0) {
                        console.warn('Empty scene data provided. No objects to load.');
                        return;
                    }
                    
                    // Clear existing simulation
                    this.simulator.clear();
                    this.rigidBodies.clear();
                    
                    // Pass 1: Create all rigid bodies
                    for (const mesh of data.meshes) {
                        if (this.isRigidBody(mesh)) {
                            this.createRigidBody(mesh);
                        }
                    }
                    
                    // Pass 2: Create joints and visual meshes
                    for (const mesh of data.meshes) {
                        if (this.isJoint(mesh)) {
                            this.createJoint(mesh);
                        } else if (this.isVisual(mesh)) {
                            this.createVisualMesh(mesh);
                        }
                    }

                    this.simulator.simulationView = true;
                    this.simulator.toggleView();

                    console.log(`Loaded scene with ${this.rigidBodies.size} rigid bodies`);
                }

                isRigidBody(mesh) {
                    const simType = mesh.properties?.simType;
                    return simType && simType.startsWith('Rigid');
                }

                isJoint(mesh) {
                    const simType = mesh.properties?.simType;
                    return simType && simType.endsWith('Joint');
                }

                isVisual(mesh) {
                    return mesh.properties?.simType === 'Visual';
                }

                createRigidBody(mesh) {
                    const props = mesh.properties;
                    const simType = props.simType;
                    const density = props.density ?? 0.0;
                    
                    // Extract position and rotation from transform
                    const pos = new THREE.Vector3(
                        mesh.transform.position[0],
                        mesh.transform.position[1],
                        mesh.transform.position[2]
                    );
                    
                    const quat = new THREE.Quaternion(
                        mesh.transform.rotation[0],
                        mesh.transform.rotation[1],
                        mesh.transform.rotation[2],
                        mesh.transform.rotation[3]
                    );
                    const euler = new THREE.Euler().setFromQuaternion(quat);
                    const angles = new THREE.Vector3(euler.x, euler.y, euler.z);

                    let rigidBody;

                    if (simType === 'RigidBox') {
                        // Calculate bounding box from vertices
                        const size = this.calculateBoundingBox(mesh.vertices);
                        rigidBody = new RigidBody(this.scene, "box", size, density, pos, angles);
                    }
                    else if (simType === 'RigidSphere') {
                        // Calculate bounding sphere radius
                        const radius = this.calculateBoundingSphere(mesh.vertices);
                        const size = new THREE.Vector3(radius, radius, radius);
                        rigidBody = new RigidBody(this.scene, "sphere", size, density, pos, angles);
                    }
                    else {
                        console.warn(`Unknown rigid body type: ${simType}`);
                        return;
                    }

                    // Store in lookup table
                    this.rigidBodies.set(mesh.name, rigidBody);
                    this.simulator.addRigidBody(rigidBody);
                    
                    console.log(`Created ${simType}: ${mesh.name}`);
                }

                calculateBoundingBox(vertices) {
                    let minX = Infinity, minY = Infinity, minZ = Infinity;
                    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;

                    // Vertices are stored as [x, y, z, x, y, z, ...]
                    for (let i = 0; i < vertices.length; i += 3) {
                        const x = vertices[i];
                        const y = vertices[i + 1];
                        const z = vertices[i + 2];

                        minX = Math.min(minX, x);
                        maxX = Math.max(maxX, x);
                        minY = Math.min(minY, y);
                        maxY = Math.max(maxY, y);
                        minZ = Math.min(minZ, z);
                        maxZ = Math.max(maxZ, z);
                    }

                    return new THREE.Vector3(
                        (maxX - minX),
                        (maxY - minY),
                        (maxZ - minZ)
                    );
                }

                calculateBoundingSphere(vertices) {
                    // Find center
                    let centerX = 0, centerY = 0, centerZ = 0;
                    const numVerts = vertices.length / 3;

                    for (let i = 0; i < vertices.length; i += 3) {
                        centerX += vertices[i];
                        centerY += vertices[i + 1];
                        centerZ += vertices[i + 2];
                    }

                    centerX /= numVerts;
                    centerY /= numVerts;
                    centerZ /= numVerts;

                    // Find maximum distance from center
                    let maxRadius = 0;
                    for (let i = 0; i < vertices.length; i += 3) {
                        const dx = vertices[i] - centerX;
                        const dy = vertices[i + 1] - centerY;
                        const dz = vertices[i + 2] - centerZ;
                        const radius = Math.sqrt(dx * dx + dy * dy + dz * dz);
                        maxRadius = Math.max(maxRadius, radius);
                    }

                    return maxRadius;
                }

                createJoint(mesh) {
                    const props = mesh.properties;
                    const simType = props.simType;
                    
                    // Look up parent bodies
                    const body0 = this.rigidBodies.get(props.parent1);
                    const body1 = this.rigidBodies.get(props.parent2);
                    
                    if (!body0) {
                        console.error(`Parent body not found: ${props.parent1}`);
                        return;
                    }
                    if (!body1) {
                        console.error(`Parent body not found: ${props.parent2}`);
                        return;
                    }

                    // Joint position (use mesh position as anchor point)
                    const jointPos = new THREE.Vector3(
                        mesh.transform.position[0],
                        mesh.transform.position[1],
                        mesh.transform.position[2]
                    );

                    // Joint rotation
                    const jointRot = new THREE.Quaternion(
                        mesh.transform.rotation[0],
                        mesh.transform.rotation[1],
                        mesh.transform.rotation[2],
                        mesh.transform.rotation[3]
                    );

                    // Create joint
                    const joint = new Joint(body0, body1, jointPos, jointRot);

                    // Configure joint based on type
                    if (simType === 'BallJoint') {
                        let swingMax = props.swingMax ?? Number.MAX_VALUE
                        let twistMin = props.twistMin ?? -Number.MAX_VALUE
                        let twistMax = props.twistMax ?? Number.MAX_VALUE
                        let damping = props.damping ?? 0.0;
                        
                        joint.initBallJoint(swingMax, twistMin, twistMax, damping);
                    }
                    else if (simType === 'HingeJoint') {
                        let swingMin = props.swingMin ?? -Number.MAX_VALUE
                        let swingMax = props.swingMax ?? Number.MAX_VALUE;
                        let hasTargetAngle = props.targetAngle !== undefined;
                        let targetAngle = props.targetAngle ?? 0.0;
                        let compliance = props.targetAngleCompliance ?? 0.0;
                        let damping = props.damping ?? 0.0;

                        joint.initHingeJoint(swingMin, swingMax, hasTargetAngle, targetAngle, compliance, damping);
                    }
                    else if (simType === 'ServoJoint') {
                        let swingMin = props.swingMin ?? -Number.MAX_VALUE
                        let swingMax = props.swingMax ?? Number.MAX_VALUE;
                        
                        joint.initServo(swingMin, swingMax);
                    }
                    else if (simType === 'MotorJoint') {
                        let velocity = props.velocity ?? 0.0;
                        velocity = 3.0;
                        joint.initMotor(velocity);
                    }
                    else if (simType === 'DistanceJoint') {
                        let restDistance = props.restDistance ?? 0.0;
                        let compliance = props.compliance ?? 0.0;
                        let damping = props.damping ?? 0.0;

                        joint.initDistanceJoint(restDistance, compliance, damping);
                    }
                    else if (simType === 'PrismaticJoint') {
                        let distanceMin = props.distanceMin ?? -Number.MAX_VALUE
                        let distanceMax = props.distanceMax ?? Number.MAX_VALUE;
                        let compliance = props.compliance ?? 0.0;
                        let damping = props.damping ?? 0.0;
                        let hasTarget = props.distanceTarget !== undefined;
                        let targetDistance = props.posTarget ?? 0.0;
                        let twistMin = props.twistMin ?? -Number.MAX_VALUE;
                        let twistMax = props.twistMax ?? Number.MAX_VALUE;
                        joint.initPrismaticJoint(distanceMin, distanceMax, twistMin, twistMax, hasTarget, targetDistance, compliance, damping);
                    }
                    else if (simType === 'CylinderJoint') {
                        let hasDistanceLimits = props.distanceMin !== undefined && props.distanceMax !== undefined;
                        let distanceMin = props.distanceMin ?? -Number.MAX_VALUE
                        let distanceMax = props.distanceMax ?? Number.MAX_VALUE;
                        let twistMin = props.twistMin ?? -Number.MAX_VALUE;
                        let twistMax = props.twistMax ?? Number.MAX_VALUE;
                        joint.initCylinderJoint(distanceMin, distanceMax, twistMin, twistMax);
                    }
                    else {
                        console.warn(`Unknown joint type: ${simType}`);
                        return;
                    }

                    // Add visuals and register with simulator
                    joint.addVisuals(this.scene);
                    this.simulator.addJoint(joint);
                    
                    console.log(`Created ${simType}: ${mesh.name} connecting ${props.parent1} to ${props.parent2}`);
                }

                createVisualMesh(mesh) {
                    const props = mesh.properties;
                    const parentName = props.parent;
                    
                    // Look up parent body
                    const parentBody = this.rigidBodies.get(parentName);
                    if (!parentBody) {
                        console.error(`Parent body not found for visual mesh: ${parentName}`);
                        return;
                    }

                    // Get visual mesh transform
                    const visualPos = new THREE.Vector3(
                        mesh.transform.position[0],
                        mesh.transform.position[1], 
                        mesh.transform.position[2]
                    );
                    
                    const visualRot = new THREE.Quaternion(
                        mesh.transform.rotation[0],
                        mesh.transform.rotation[1],
                        mesh.transform.rotation[2],
                        mesh.transform.rotation[3]
                    );

                    // Transform visual mesh to parent body local space

                    const q_rel = parentBody.rot.clone().conjugate().multiply(visualRot);
                    const p_rel = visualPos.clone().sub(parentBody.pos).applyQuaternion(parentBody.rot.clone().conjugate());

                    const transformedVertices = [];
                    for (let i = 0; i < mesh.vertices.length; i += 3) {
                        const vertex = new THREE.Vector3(mesh.vertices[i], mesh.vertices[i + 1], mesh.vertices[i + 2]);
                        vertex.applyQuaternion(q_rel);
                        vertex.add(p_rel);
                        
                        transformedVertices.push(vertex.x, vertex.y, vertex.z);
                    }

                    const transformedNormals = [];
                    if (mesh.normals) {
                        for (let i = 0; i < mesh.normals.length; i += 3) {
                            const normal = new THREE.Vector3(mesh.normals[i], mesh.normals[i + 1], mesh.normals[i + 2]);
                            normal.applyQuaternion(q_rel);
                            transformedNormals.push(normal.x, normal.y, normal.z);
                        }
                    }

                    // Create Three.js geometry from transformed data
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(transformedVertices, 3));
                    
                    if (transformedNormals.length > 0) {
                        geometry.setAttribute('normal', new THREE.Float32BufferAttribute(transformedNormals, 3));
                    }
                    
                    if (mesh.triangles) {
                        geometry.setIndex(mesh.triangles);
                    }

                    const color = props.color ? new THREE.Color(props.color[0], props.color[1], props.color[2]) : new THREE.Color(1, 1, 1);
                    const material = new THREE.MeshPhongMaterial({ color: color });

                    // Create mesh
                    const visualMesh = new THREE.Mesh(geometry, material);
                    visualMesh.castShadow = true;
                    visualMesh.receiveShadow = true;
                    visualMesh.body = parentBody; // For raycasting

                    parentBody.meshes.push(visualMesh);
                    parentBody.updateMeshes();
                    
                    this.scene.add(visualMesh);
                    
                    console.log(`Created visual mesh: ${mesh.name} attached to ${parentName} (transformed to body space)`);
                }
            }

            // ------------------------------------------------------------------

            class RenderScene
            {
                constructor()
                {
                    this.threeScene = new THREE.Scene();

                    // Lights
                    this.threeScene.add(new THREE.AmbientLight(0x505050));
                    this.threeScene.fog = new THREE.Fog(0x000000, 0.0, 15.0);

                    var spotLight = new THREE.SpotLight(0xffffff);
                    spotLight.angle = Math.PI / 5;
                    spotLight.penumbra = 0.2;
                    spotLight.position.set(2, 3, 2);
                    this.threeScene.add(spotLight);

                    var dirLight = new THREE.DirectionalLight(0x55505a, 1);
                    dirLight.position.set(0, 10, 0); 
                    dirLight.castShadow = true;
                    dirLight.shadow.camera.near = 1;
                    dirLight.shadow.camera.far = 20; 

                    dirLight.shadow.camera.right = 10;
                    dirLight.shadow.camera.left = -10;
                    dirLight.shadow.camera.top = 10;
                    dirLight.shadow.camera.bottom = -10;

                    dirLight.shadow.mapSize.width = 2048; 
                    dirLight.shadow.mapSize.height = 2048;
                    dirLight.shadow.blurSamples = 10;
                    dirLight.shadow.radius = 2.0;
                    this.threeScene.add(dirLight);

                    // Geometry
                    let ground = new THREE.Mesh(
                        new THREE.PlaneBufferGeometry(50.0, 50.0),
                        new THREE.MeshPhongMaterial({ color: 0xa0adaf, shininess: 150 })
                    );

                    ground.rotation.x = -Math.PI / 2; // rotates X/Y to X/Z
                    ground.receiveShadow = true;
                    this.threeScene.add(ground);

                    // Renderer
                    this.renderer = new THREE.WebGLRenderer({ antialias: true });
                    this.renderer.shadowMap.enabled = true;
                    this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;  // Softer shadows
                    this.renderer.setPixelRatio(window.devicePixelRatio);
                    this.renderer.setSize(0.8 * window.innerWidth, 0.8 * window.innerHeight);
                    window.addEventListener('resize', onWindowResize, false);
                    container.appendChild(this.renderer.domElement);

                    // Camera
                    this.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 100);
                    this.camera.position.set(0, 0.4, 1.2);
                    this.camera.updateMatrixWorld();
                    this.threeScene.add(this.camera);

                    this.cameraControl = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.cameraControl.zoomSpeed = 2.0;
                    this.cameraControl.panSpeed = 0.4;
                    this.cameraControl.target = new THREE.Vector3(0.0, 0.4, 0.0);
                    this.cameraControl.update();

                    this.raycaster = new THREE.Raycaster();
                    this.raycaster.layers.set(1);
                    this.raycaster.params.Line.threshold = 0.1;

                    this.meshes = [];
                }

                render()
                {
                    this.renderer.render(this.threeScene, this.camera);
                }

                add(mesh)
                {
                    this.threeScene.add(mesh);
                    this.meshes.push(mesh);
                }

                clear()
                {
                    for (let i = 0; i < this.meshes.length; i++)
                    {
                        this.threeScene.remove(this.meshes[i]);
                    }
                    this.meshes = [];
                }
            }

            var gRenderScene = null;
            var gSimulator = null;
            var gPaused = true;

			// ------------------------------------------------------

			function onWindowResize() {
                if (gRenderScene == null)
                    return;
				gRenderScene.camera.aspect = window.innerWidth / window.innerHeight;
				gRenderScene.camera.updateProjectionMatrix();
				gRenderScene.renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function onStart() {
				var button = document.getElementById("startButton");
				if (gPaused)
					button.innerHTML = "Stop";
				else
					button.innerHTML = "Start";
				gPaused = !gPaused;
			}

			function onRestart() {
                window.location.reload();
			}

            function onToggleView()
            {
                gSimulator.toggleView();
            }

            function onSceneChange() {
                const select = document.getElementById('sceneSelect');
                loadScene(parseInt(select.value));
            }

            var gPointerInfo = 
            { 
                mousePos : new THREE.Vector2(),
                worldPos : new THREE.Vector3(),
                distance : 0.0,
            };
            
            function onPointer( evt ) 
			{
				event.preventDefault();

                var rect = gRenderScene.renderer.domElement.getBoundingClientRect();
				gPointerInfo.mousePos.x = ((evt.clientX - rect.left) / rect.width ) * 2 - 1;
				gPointerInfo.mousePos.y = -((evt.clientY - rect.top) / rect.height ) * 2 + 1;
                gRenderScene.raycaster.setFromCamera(gPointerInfo.mousePos, gRenderScene.camera);

				if (evt.type == "pointerdown") {
                    var intersects = gRenderScene.raycaster.intersectObjects(gRenderScene.threeScene.children);
					if (intersects.length > 0) {
                        gPointerInfo.distance = intersects[0].distance;
                        gPointerInfo.worldPos.copy(gRenderScene.raycaster.ray.origin);
                        gPointerInfo.worldPos.addScaledVector(gRenderScene.raycaster.ray.direction, gPointerInfo.distance);
                        gPointerInfo.body = intersects[0].object.body;
                        if (gPointerInfo.body)
                        {
                            gRenderScene.cameraControl.saveState();
						    gRenderScene.cameraControl.enabled = false;
                            gSimulator.startDrag(gPointerInfo.body, gPointerInfo.worldPos);
                            if (gPaused)
                                onStart(); 
                        }
                        else
                            gPointerInfo.body = null;
                    }
				}
				else if (evt.type == "pointermove" && gPointerInfo.body != null) {
                    gPointerInfo.worldPos.copy(gRenderScene.raycaster.ray.origin);
                    gPointerInfo.worldPos.addScaledVector(gRenderScene.raycaster.ray.direction, gPointerInfo.distance);
                    gSimulator.drag(gPointerInfo.worldPos);
				}
				else if (evt.type == "pointerup") {
                    if (gPointerInfo.body != null)
                    {
                        gSimulator.endDrag();
                        gPointerInfo.body = null;
                        gRenderScene.cameraControl.reset();
                    }
                    gRenderScene.cameraControl.enabled = true;
                }
			}	

            container.addEventListener( 'pointerdown', onPointer, false );
			container.addEventListener( 'pointermove', onPointer, false );
			container.addEventListener( 'pointerup', onPointer, false );

			// make browser to call us repeatedly -----------------------------------

			function update() {
				if (!gPaused) {
                    gSimulator.simulate();
                }
                gRenderScene.render();
				requestAnimationFrame(update);
			}
					            
            // Scene definitions
            const jointScenes = [
                { path: './basicJoints.json', name: 'Basic Joints' },
                { path: './steering.json', name: 'Steering' },
                { path: './pendulum.json', name: 'Pendulum' }
            ];

            function loadScene(sceneIndex) {
                gRenderScene.clear();
                gSimulator.clear();

                fetch(jointScenes[sceneIndex].path)
                .then(response => response.json())
                .then(scene => {
                    console.log('Scene loaded:', scene);
                    let importer = new SceneImporter(gSimulator, gRenderScene);
                    importer.loadScene(scene);
                });
            }

  			gRenderScene = new RenderScene();
            let gravity = new THREE.Vector3(0.0, -9.81, 0.0);
            gSimulator = new RigidBodySimulator(gRenderScene, gravity);

            loadScene(2); // Load the first scene by default

            onWindowResize();
			update();
		</script>
	</body>
</html>
